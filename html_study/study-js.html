<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script>
    // number
    var num1 = 1;
    let number = Number("-999");
    console.log(number)
    console.log(parseInt("-88iji"))
    console.log(parseFloat("3.14"))

    // alert("hello");
    var arr = [1, 2, 3.14, 'Hello', null, true];
    var a = arr[0];
    var b = arr[3];
    var c = arr[30];
    console.log(a)
    console.log(b)
    console.log(c)

    var person = {name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null};
    console.log(person)

    var name = '小明';
    var age = 20;
    var message = `你好, ${name}, 你今年${age}岁了!`;
    // alert(message);

    var filterArr = [10, 20, 30, 40];
    // filter
    var filterArraff = filterArr.filter(function (item, index, array) {
      return item > 20;
    })
    console.log("filterArraff:" + filterArraff)
    // map
    var filterArrMap = filterArr.map(function (item, index, array) {
      return item + 20;
    })
    console.log("filterArrMap:" + filterArrMap)
    // foreach
    filterArr.forEach(function (value, index, array) {
      console.log(value)
    })


    var arr = [10, 20, '30', 'xyz'];
    console.log(arr.toString())
    arr.indexOf(10); // 元素10的索引为0
    arr.indexOf(20); // 元素20的索引为1
    arr.indexOf(30); // 元素30没有找到，返回-1
    arr.indexOf('30'); // 元素'30'的索引为2
    let array = new Array();

    var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
    arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']
    arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']

    var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
    var aCopy = arr.slice();
    aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
    aCopy === arr; // false

    // push() 向 Array 的末尾添加若干元素， pop() 则把 Array 的最后一个元素删除掉
    var arr = [1, 2];
    arr.push('A', 'B'); // 返回Array新的长度: 4
    arr.pop(); // pop()返回'B'
    // 如果要往 Array 的头部添加若干元素，使用 unshift() 方法， shift() 方法则把 Array 的第一个元素删掉
    // sort() 可以对当前 Array 进行排序，
    // reverse() 把整个 Array 的元素给掉个个，也就是反转
    // splice() 方法是修改 Array 的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素
    var arr = ['Microsoft', 'Apple', 'Yahoo', 'AOL', 'Excite', 'Oracle']; // 从索引2开始删除3个元素,然后再添加两个元素:
    arr.splice(2, 3, 'Google', 'Facebook'); // 返回删除的元素 ['Yahoo', 'AOL', 'Excite']
    // concat() 方法把当前的 Array 和另一个 Array 连接起来，并返回一个新的 Array
    var arr = ['A', 'B', 'C'];
    var added = arr.concat([1, 2, 3]);
    added; // ['A', 'B', 'C', 1, 2, 3]
    // join() 方法是一个非常实用的方法，它把当前 Array 的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：
    var arr = ['A', 'B', 'C', 1, 2, 3];
    arr.join('-'); // 'A-B-C-1-2-3'

    // 如果我们要检测对象是否拥有某一属性，可以用 in 操作符：
    var xiaoming = {name: '小明', birth: 1990, school: 'No.1 Middle School', height: 1.70, weight: 65, score: null};
    'name' in xiaoming; // true 'grade' in xiaoming; // false
    // 不过要小心，如果用 in 判断一个属性存在，这个属性不一定是 这个对象的，它可能是这个对象继承得到的：
    'toString' in xiaoming; // true
    var xiaoming = {name: '小明'};
    // 要判断一个属性是否是 xiaoming 自身拥有的，而不是继承得到的，可以用 hasOwnProperty() 方法：
    xiaoming.hasOwnProperty('name'); // true
    xiaoming.hasOwnProperty('toString'); // false

    var o = {name: 'Jack', age: 20, city: 'Beijing'};
    for (var key in o) {
      if (o.hasOwnProperty(key)) {
        console.log(key + " " + o[key]); // 'name', 'age', 'city'
      }
    }

    var a = ['A', 'B', 'C'];
    for (var i in a) {
      console.log(i + " " + a[i]); // '0', '1', '2'
    }

    var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
    var cc = m.get('Michael'); // 95
    console.log(cc);

    var m = new Map(); // 空Map
    m.set('Adam', 67); // 添加新的key-value
    m.set('Bob', 59);
    m.has('Adam'); // 是否存在key 'Adam': true
    m.get('Adam'); // 67
    m.delete('Adam');// 删除key 'Adam'
    m.get('Adam'); // undefined 1234567

    var s1 = new Set(); // 空Set
    var s2 = new Set([1, 2, 3]); // 含1, 2, 3
    var s = new Set([1, 2, 3, 3, '3']);
    s; // Set {1, 2, 3, "3"}

    var a = ['A', 'B', 'C'];
    var s = new Set(['A', 'B', 'C']);
    var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
    for (var x of a) {
      console.log(x);
    }
    for (var x1 of s) {
      console.log(x1);
    }
    for (var x2 of m) {
      console.log(x2);
    }

    // forEach() 方法是ES5.1标准引入的，你需要测试浏览器是否支持。Set没有索引，因此回调函数的前两个参数都是元素本身：
    var s = new Set(['A', 'B', 'C']);
    s.forEach(function (element, sameElement, set) {
      console.log(element);
    });
    //Map 的回调函数参数依次为 value 、 key 和 map 本身
    var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
    m.forEach(function (value, key, map) {
      console.log(value);
    });


    // 一旦执行到 return 时，函数就执行完毕，并将结果返回。如果没有 return 语句，函数执行完毕后也会返回结果，只是结果为 undefined 。
    function abs(x) {
      if (x >= 0) {
        return x;
      } else {
        return -x;
      }
    }

    // 在这种方式下， function (x) { ... } 是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量 abs ，所以，通过变量 abs 就可以调用该函数。
    // 上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个 ; ，表示赋值语句结束。
    var abs = function (x) {
      if (typeof x !== 'number') {
        throw 'Not a number';
      }
      if (x >= 0) {
        return x;
      } else {
        return -x;
      }
    };
    console.log(abs(10)); // 返回10
    console.log(abs(-9)); // 返回9

    // 利用 arguments ，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：
    function abs() {
      if (arguments.length === 0) {
        return 0;
      }
      var x = arguments[0];
      return x >= 0 ? x : -x;
    }

    // 实际上 arguments 最常用于判断传入参数的个数。你可能会看到这样的写法：
    function aoo(a, b, c) {
      if (argumfents.length === 2) {
      }
    }

    function foo(a, b) {
      var i, rest = [];
      if (arguments.length > 2) {
        for (i = 2; i < arguments.length; i++) {
          rest.push(arguments[i]);
        }
      }
      console.log('a = ' + a);
      console.log('b = ' + b);
      console.log(rest);
    }

    function foo(a, b, ...rest) {
      console.log('a = ' + a);
      console.log('b = ' + b);
      console.log(rest);
    }

    foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ]
    foo(1); // 结果: // a = 1 // b = undefined // Array []


    // 唯一的全局变量MYAPP:
    var MYAPP = {};
    // 其他变量:
    MYAPP.name = 'myapp';
    MYAPP.version = 1.0;
    // 其他函数:
    MYAPP.foo = function () {
      return 'foo';
    };

    // 为了解决块级作用域，ES6引入了新的关键字 let ，用 let 替代 var 可以申明一个块级作用域的变量：
    function foo() {
      var sum = 0;
      for (let i = 0; i < 100; i++) {
        sum += i;
      }
      // SyntaxError:
      i += 1;
    }

    // ES6标准引入了新的关键字 const 来定义常量， const 与 let 都具有块级作用域：
    const PI = 3.14;
    // PI = 3; // 某些浏览器不报错，但是无效果！
    PI; // 3.14


    // 绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个 this 关键字，这个东东是什么？
    // 在一个方法内部， this 是一个特殊变量，它始终指向当前对象，也就是 xiaoming 这个变量。
    // 所以， this.birth 可以拿到 xiaoming 的 birth 属性。
    var xiaoming = {
      name: '小明',
      birth: 1995,
      age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
      }
    };
    var l = xiaoming.age; // function xiaoming.age()
    var lll = xiaoming.age(); // 今年调用是25,明年调用就变成26了
    console.log(l)
    console.log(lll)

    function getAge() {
      var y = new Date().getFullYear();
      return y - this.birth;
    }

    // 我们还是可以控制 this 的指向的！要指定函数的 this 指向哪个对象，可以用函数本身的 apply 方法，它接收两个参数，第一个参数
    // 就是需要绑定的 this 变量，第二个参数是 Array ，表示函数本身的参数。
    var xiaoming = {name: '小明', birth: 1990, age: getAge};
    xiaoming.age(); // 25
    getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 12345678910111213

    // 在JavaScript的世界里，一切都是对象。但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用 typeof 操作符获取对象的类
    //型，它总是返回一个字符串：
    typeof 123; // 'number'
    typeof NaN; // 'number'
    typeof 'str'; // 'string'
    typeof true; // 'boolean'
    typeof undefined; // 'undefined'

    // date
    var now = new Date();
    now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
    now.getFullYear(); // 2015, 年份
    now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
    now.getDate(); // 24, 表示24号
    now.getDay(); // 3, 表示星期三
    now.getHours(); // 19, 24小时制
    now.getMinutes(); // 49, 分钟
    now.getSeconds(); // 22, 秒
    now.getMilliseconds(); // 875, 毫秒数
    now.getTime(); // 1435146562875, 以number形式表示的时间戳

    // var ds = "2021-09-01 00:00:00".replace(/-/g, "/");
    var startTime = Date.parse("2021-01-01");
    var endTIme = Date.parse("2021-04-20");
    let date = new Date(startTime);
    let endTime = new Date(endTIme);
    console.log("当前月份：" + (date.getMonth() + 1))

    months = (endTime.getFullYear() - date.getFullYear()) * 12 + ((endTime.getMonth() + 1) - (date.getMonth() + 1)) + 1;

    console.log("相差的月份 " + months);
    if (endTime < startTime) {
      console.log("xixooxoxoxo")
    }
    console.log(date)
    console.log(date.getMonth() + 1)
    console.log(endTime.getMonth() + 1)
    let sta = date.getMonth() + 1
    let end = endTime.getMonth() + 1
    if (sta === 12) {
      if (sta >= 3) {
        console.log("error")
      }
    }
    if (end - sta > 3) {
      console.log("dale")
    }

    var dayNum = (endTIme - startTime) / (1000 * 3600 * 24);
    var days = parseInt(Math.ceil(dayNum));
    console.log("dayNUm:" + days)

    var d = new Date(1435146562875);
    d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字 符串与操作系统设定的格式有关
    d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时

    var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的
    var json = '{"a": "Hello", "b": "World"}'; //这是一个 JSON 字符串，本质是一个字符串
    // 从JSON字符串转换为JavaScript 对象
    var obj = JSON.parse('{"a": "Hello", "b": "World"}'); //结果是 {a: 'Hello', b: 'World'}
    // 现从JavaScript 对象转换为JSON字符串
    var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{"a": "Hello", "b": "World"}'

    // encodeURI encodeURIComponent
    var str = 'https://quanbai.com/index.html'
    console.log(encodeURI(str))
    console.log(encodeURIComponent(str))
    var enStr = "https%3A%2F%2Fquanbai.com%2Findex.html";
    console.log(decodeURIComponent(enStr))


  </script>
</head>
<body>

</body>
</html>
